import os
import time
import datetime
from lxml import etree
import psycopg2

'''
Function for calculating the elapsed time of an action

Input:  start time type time
        end time type time

Output: elapsed time in seconds
'''
def elapsed_time(start, end):
    elapsed = round(((end - start) % 60), 2)

    return (str(elapsed) + 'seconds')

'''
Variable for DBLP file

Input: a file in XML format

Source file location: http://dblp.uni-trier.de/xml/

File version date: 11 March 2017
'''
dblp_xml_file_name = 'dblp-2017-03-03.xml'

'''
Variable for the location of DBLP file.
In our program, we have a directory named 'data'.  Inside this directory, there are two files:
(1) dblp.dtd and (2) dblp.xml.  The (1) is the data definition for the xml and the (2) is the dblp data.
'''
file_location = os.path.abspath(os.path.join('data', dblp_xml_file_name))

'''
Variable for the DBLP XML file using its DTD file.
'''
parser = etree.XMLParser(dtd_validation=True)

'''
Initializing time and date markers for parsing the XML file
'''
parse_start_time = time.time()
parse_start_date = datetime.datetime.now()
print(str(parse_start_date) + ': Start to parse the xml data...')

'''
Parsing the DBLP XML file
'''
doc = etree.parse(file_location, parser)

'''
Ending time and date markers for parsing the XML file
'''
parse_end_time = time.time()
parsed_end_date = datetime.datetime.now()
print('Parsed within ' + elapsed_time(parse_start_time, parse_end_time) + ' and ended on ' + str(parsed_end_date))

'''
Getting the root of the DBLP XML file
'''
root = doc.getroot()

'''
Initializing the required counter for collecting data migration statistics
'''
article_counter = 0
inproceedings_counter = 0
proceedings_counter = 0
book_counter = 0
incollection_counter = 0
phdthesis_counter = 0
mastersthesis_counter = 0
www_counter = 0

'''
Establishing connection to PostgreSQL RDBMS.
In this program, I use PostgreSQL DBMS to store the DBLP data.
The name of the database is "dblp".
The database user that I use in this progam is named "satrio".
At this program, I do not use any password to access the database.
I use psycopg2 python library as the PostgreSQL adapter.

The syntax for establishing connection:
conn = psycopg2.connect("dbname=database-name user=database-username password=user-password-if-any")
'''
conn = psycopg2.connect("dbname=dblp user=satrio")
cur = conn.cursor()

'''
Initializing time and date marker for iterating the root's children
'''
iteration_start_time = time.time()
iteration_start_date = datetime.datetime.now()
print(str(iteration_start_date) + ': Start the migration process...')

'''
Iterating root's children.
The children composed of article|inproceedings|proceedings|book|incollection|phdthesis|mastersthesis|www
'''
for children in root:
    '''
    Initializing child's attributes.
    IMPORTANT: not all children have these attributes but we initialized them anyway so their are there when they are
    needed.
    '''
    key = None
    mdate = None
    publtype = None
    reviewid = None
    rating = None

    '''
    Initializing child's sub-elements.
    Some sub-elements are initialized as empty lists due to the nature of the data of those sub-elements
    '''
    editor = None
    title = None
    booktitle = None
    pages = None
    year = None
    address = None
    journal = None
    volume = None
    number = None
    month = None
    url = None
    cdrom = None
    publisher = None
    note = None
    crossref = None
    isbn = None
    series = None
    school = None
    chapter = None
    author = []
    cite = []
    ee = []

    '''
    Iterating through the child's attribute for assigning the attribute value to a variable
    '''
    for attribute_name, attribute_value in children.items():
        if(attribute_name == 'key'):
            key = attribute_value
        if(attribute_name == 'mdate'):
            mdate = attribute_value
        if(attribute_name == 'publtype'):
            publtype = attribute_value
        if(attribute_name == 'reviewid'):
            reviewid = attribute_value
        if(attribute_name == 'rating'):
            rating = attribute_value

    '''
    Retrieving DBLP data value through iterating the root's grandchildren
    The following are the root's children:
    - author
    - editor
    - title
    - booktitle
    - pages
    - year
    - address
    - journal
    - volume
    - number
    - month
    - url
    - ee
    - cdrom
    - cite
    - publisher
    - note
    - crossref
    - isbn
    - series
    - school
    - chapter
    Some of these grandchildren's value may be NULL
    '''
    for grand_children in children:
        if (grand_children.tag == 'author'):
            '''
            Intializing time marker for checking author data in the database.
            '''
            check_author_start = time.time()

            print('Checking the existence of author data in the database...')

            '''
            Querying data in the database.
            Input: key from the children's attribute
                   author from the value of the grand children's tag
            '''
            query = 'SELECT key, author FROM author WHERE key = %s AND author = %s'
            cur.execute(query, (str(key), str(grand_children.text)))

            '''
            Ending time marker for checking author data in the database.
            '''
            check_author_end = time.time()

            print('Checked within ' + elapsed_time(check_author_start, check_author_end))

            '''
            Check the query result.
            If the author has not yet exist in the database then we add the new author to the database
            Else we print out a notification which says that the author already existed in the database and we ignore it.
            '''
            if (cur.fetchone() is None):
                print('Inserting ' + str(key) + ', ' + str(grand_children.text) + ' into AUTHOR table in database')

                '''
                Initializing time marker for author data insertion
                '''
                author_start = time.time()

                '''
                Inserting new author to the database
                '''
                query = "INSERT INTO author(key,author) VALUES (%s, %s)"
                cur.execute(query, (str(key), str(grand_children.text)))
                conn.commit()

                '''
                Ending time marker for author data insertion
                '''
                author_end = time.time()

                print(str(key) + ', ' + str(grand_children.text) + ' has been inserted within ' + elapsed_time(
                    author_start, author_end))
            else:
                print('Author data: ' + str(key) + ', ' + str(grand_children.text) + ' already existed in the database')

        elif (grand_children.tag == 'editor'):
            '''
            Initializing time marker for checking editor data in the database.
            '''
            check_editor_start = time.time()

            print('Checking existing editor data...')

            '''
            Querying data in the database.
            Input: key from the children's attribute
                   editor from the value of the grand children's tag
            '''
            query = 'SELECT key, editor FROM editor WHERE key = %s AND editor = %s'
            cur.execute(query, (str(key), str(grand_children.text)))

            '''
            Ending time marker for checking editor data in the database.
            '''
            check_editor_end = time.time()

            print('Checked within ' + elapsed_time(check_editor_start, check_editor_end))

            '''
            Check the query result.
            If the editor has not yet exist in the database then we add the new editor to the database
            Else we print out a notification which says that the editor already existed in the database and we ignore it.
            '''
            if (cur.fetchone() is None):
                print('Inserting ' + str(key) + ', ' + str(grand_children.text) + ' into EDITOR table in database')

                '''
                Initializing time marker for editor data insertion
                '''
                editor_start = time.time()

                '''
                Inserting new editor to the database
                '''
                query = 'INSERT INTO editor(key, editor) VALUES (%s, %s)'
                cur.execute(query, (str(key), str(grand_children.text)))
                conn.commit()

                '''
                Ending time marker for editor data insertion
                '''
                editor_end = time.time()

                print(str(key) + ', ' + str(grand_children.text) + ' has been inserted within ' + elapsed_time(editor_start, editor_end))
            else:
                print('Editor data: ' str(key) + ', ' + str(grand_children.text) + ' already existed in database')


        elif (grand_children.tag == 'title'):
            title = str(grand_children.text)

        elif (grand_children.tag == 'booktitle'):
            booktitle = str(grand_children.text)

        elif (grand_children.tag == 'pages'):
            pages = str(grand_children.text)

        elif (grand_children.tag == 'year'):
            year = str(grand_children.text)

        elif (grand_children.tag == 'address'):
            address = str(grand_children.text)

        elif (grand_children.tag == 'journal'):
            journal = str(grand_children.text)

        elif (grand_children.tag == 'volume'):
            volume = str(grand_children.text)

        elif (grand_children.tag == 'number'):
            number = str(grand_children.text)

        elif (grand_children.tag == 'month'):
            month = str(grand_children.text)

        elif (grand_children.tag == 'url'):
            url = str(grand_children.text)

        elif (grand_children.tag == 'ee'):
            '''
            Initializing time marker for checking ee data in the database
            '''
            check_ee_start = time.time()

            print('Checking existing ee data...')

            '''
            Querying data in the database.
            Input: key from the children's attribute
                   ee from the value of the grand children's tag
            '''
            query = 'SELECT key, ee FROM ee WHERE key = %s AND ee = %s'
            cur.exeucte(query, (str(key), str(grand_children.text)))

            '''
            Ending time marker for checking ee data in the database
            '''
            check_ee_end = time.time()

            print('Checked within ' + elapsed_time(check_ee_start, check_ee_end))

            '''
            Check the query result.
            If the ee has not yet exist in the database then we add the new ee to the database
            Else we print out a notification which says that the ee already existed in the database and we ignore it.
            '''
            if (cur.fetchone() is None):
                print('Inserting ' + str(key) + str(grand_children.text) + ' into EE table in database')

                '''
                Initializing time marker for ee data insertion
                '''
                ee_start = time.time()

                '''
                Inserting new ee into the database
                '''
                query = "INSERT INTO ee(key, ee) VALUES (%s, %s)"
                cur.execute(query, (str(key), str(grand_children.text)))
                conn.commit()

                '''
                Ending time marker for ee data insertion
                '''
                ee_end = time.time()

                print(str(key) + ', ' + str(grand_children.text) + ' has been inserted within ' + elapsed_time(ee_start, ee_end))
            else:
                print('Ee data: ' + str(key) + ', ' + str(grand_children.text) + ' already existed in database')

        if (grand_children.tag == 'cdrom'):
            cdrom = str(grand_children.text)
        if (grand_children.tag == 'cite'):
            '''
            Initializing time marker for checking cite data in the database
            '''
            check_cite_start = time.time()

            print('Checking existing cite data...')

            '''
            Querying data in the database.
            Input: key from the children's attribute
                   cite from the value of the grand children's tag
            '''
            query = "SELECT key, cite FROM cite WHERE key = %s AND cite = %s"
            cur.execute(query, (str(key), str(grand_children.text)))

            '''
            Ending time marker for checking cite data in the database
            '''
            check_cite_end = time.time()

            print('Checked within ' + elapsed_time(check_cite_start, check_cite_end))

            '''
            Check the query result.
            If the cite has not yet exist in the database then we add the new cite to the database
            Else we print out a notification which says that the cite already existed in the database and we ignore it.
            '''
            if (cur.fetchone() is None):
                print('Inserting ' + str(key) + str(grand_children.text) + ' into CITE table in DBLP database')

                '''
                Initializing time marker for cite data insertion
                '''
                cite_start = time.time()

                '''
                Inserting new cite data
                '''
                query = "INSERT INTO cite(key, cite) VALUES (%s, %s)"
                cur.execute(query, (str(key), str(grand_children.text)))
                conn.commit()

                '''
                Ending time marker for cite data insertion
                '''
                cite_end = time.time()
                print(str(key) + ', ' + str(grand_children.text) + ' has been inserted within ' + elapsed_time(cite_start, cite_end))
            else:
                print('Cite data: ' + str(key) + ', ' + str(grand_children.text) + ' already existed in database')

        elif (grand_children.tag == 'publisher'):
            publisher = str(grand_children.text)
        elif (grand_children.tag == 'note'):
            note = str(grand_children.text)
        elif (grand_children.tag == 'crossref'):
            crossref = str(grand_children.text)
        elif (grand_children.tag == 'isbn'):
            isbn = str(grand_children.text)
        elif (grand_children.tag == 'series'):
            series = str(grand_children.text)
        elif (grand_children.tag == 'school'):
            school = str(grand_children.text)
        elif (grand_children.tag == 'chapter'):
            chapter = str(grand_children.text)

'''
Ending time and date marker for iterating the root's childres
'''
iteration_end_time = time.time()
iteration_end_date = datetime.datetime.now()
print('The migration process finished within ' + elapsed_time(iteration_start_time, iteration_end_time) + ' and ended on ' + str(iteration_end_date))